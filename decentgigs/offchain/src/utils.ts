/**
 * ===================================================================
 * DecentGigs Smart Contract Utilities
 * ===================================================================
 *
 * This module provides utility functions for interacting with the
 * DecentGigs escrow smart contract on Cardano.
 *
 * Key Features:
 * - Load and parse Plutus validators
 * - Create and serialize job datums
 * - Generate redeemers for contract actions
 * - Type-safe data schemas using Lucid Evolution
 *
 * ===================================================================
 */

import { Data, SpendingValidator, fromText } from "@lucid-evolution/lucid";
import * as fs from "fs";

// ===================================================================
// DATA SCHEMAS
// ===================================================================

/**
 * Job Datum Schema
 *
 * Defines the structure of data locked in the escrow contract.
 * This datum contains information about the job and the parties involved.
 *
 * Fields:
 * - employer: Verification key hash of the employer
 * - freelancer: Verification key hash of the freelancer
 * - job_id: Unique identifier for the job (as ByteArray)
 *
 * This schema must match the JobDatum type in the Aiken contract:
 * ```aiken
 * pub type JobDatum {
 *   employer: VerificationKeyHash,
 *   freelancer: VerificationKeyHash,
 *   job_id: ByteArray,
 * }
 * ```
 */
const JobDatumSchema = Data.Object({
  employer: Data.Bytes(),
  freelancer: Data.Bytes(),
  job_id: Data.Bytes(),
});

/**
 * JobDatum Type
 *
 * TypeScript type derived from the JobDatum schema.
 * Used for type-safe datum creation and parsing.
 */
type JobDatum = Data.Static<typeof JobDatumSchema>;
export const JobDatum = JobDatumSchema as unknown as JobDatum;

/**
 * Job Action Schema
 *
 * Defines the redeemer actions that can be performed on the contract.
 *
 * Actions:
 * - ReleasePayment: Release locked funds to freelancer (job completed)
 * - CancelJob: Return locked funds to employer (job cancelled)
 *
 * This schema must match the JobAction type in the Aiken contract:
 * ```aiken
 * pub type JobAction {
 *   ReleasePayment
 *   CancelJob
 * }
 * ```
 */
const JobActionSchema = Data.Enum([
  Data.Object({ ReleasePayment: Data.Tuple([]) }),
  Data.Object({ CancelJob: Data.Tuple([]) }),
]);

/**
 * JobAction Type
 *
 * TypeScript type derived from the JobAction schema.
 * Used for type-safe redeemer creation.
 */
type JobAction = Data.Static<typeof JobActionSchema>;
export const JobAction = JobActionSchema as unknown as JobAction;

// ===================================================================
// VALIDATOR FUNCTIONS
// ===================================================================

/**
 * Read Validator from Plutus JSON
 *
 * Loads the compiled Plutus validator from plutus.json file.
 * This file is generated by the Aiken compiler when building the contract.
 *
 * The validator is a PlutusV3 script that enforces the business logic
 * of the escrow contract on-chain.
 *
 * @returns SpendingValidator object containing the compiled script
 * @throws Error if plutus.json not found or validator not in file
 *
 * @example
 * ```typescript
 * const validator = readValidator();
 * const scriptAddress = validatorToAddress("Preprod", validator);
 * ```
 */
export function readValidator(): SpendingValidator {
  // Read and parse plutus.json
  const plutusJson = JSON.parse(fs.readFileSync("plutus.json", "utf8"));

  // Find the specific validator by title
  // The title format is: <module>.<validator>.<endpoint>
  const validator = plutusJson.validators.find(
    (v: any) => v.title === "decentgigs.decentgigs.spend"
  );

  if (!validator) {
    throw new Error(
      "Validator 'decentgigs.decentgigs.spend' not found in plutus.json\n" +
      "Make sure you've built the Aiken contract using: aiken build"
    );
  }

  // Return as SpendingValidator with PlutusV3 type
  return {
    type: "PlutusV3",
    script: validator.compiledCode,
  };
}

// ===================================================================
// DATUM FUNCTIONS
// ===================================================================

/**
 * Create Job Datum
 *
 * Creates a serialized datum for locking funds in the escrow contract.
 * This datum contains all the information needed to validate
 * release or cancellation of the job.
 *
 * @param employerPkh - Employer's public key hash (verification key hash)
 * @param freelancerPkh - Freelancer's public key hash (verification key hash)
 * @param jobId - Unique identifier for the job (default: "default_job_001")
 *
 * @returns Serialized CBOR datum as hex string
 *
 * @example
 * ```typescript
 * const employerPkh = getAddressDetails(employerAddress).paymentCredential.hash;
 * const freelancerPkh = getAddressDetails(freelancerAddress).paymentCredential.hash;
 * const datum = createJobDatum(employerPkh, freelancerPkh, "project_abc_001");
 * ```
 *
 * Usage in transaction:
 * ```typescript
 * tx.pay.ToAddressWithData(
 *   scriptAddress,
 *   { kind: "inline", value: datum },
 *   { [USDM_UNIT]: amount }
 * )
 * ```
 */
export function createJobDatum(
  employerPkh: string,
  freelancerPkh: string,
  jobId: string = "default_job_001"
): string {
  // Create datum object matching the schema
  const datum: JobDatum = {
    employer: employerPkh,
    freelancer: freelancerPkh,
    job_id: fromText(jobId), // Convert UTF-8 string to ByteArray
  };

  // Serialize to CBOR format
  return Data.to(datum, JobDatum);
}

// ===================================================================
// REDEEMER CONSTANTS
// ===================================================================

/**
 * Release Payment Redeemer
 *
 * Redeemer for releasing locked funds to the freelancer.
 * Use this when the job is completed successfully.
 *
 * Smart Contract Validation:
 * - Both employer and freelancer must sign
 * - Payment amount must match locked amount
 * - Funds must go to freelancer's address
 *
 * @constant
 * @type {string} Serialized CBOR redeemer
 *
 * @example
 * ```typescript
 * const tx = await lucid
 *   .newTx()
 *   .collectFrom([utxo], redeemerRelease)
 *   .attach.SpendingValidator(validator)
 *   .pay.ToAddress(freelancerAddress, assets)
 *   .addSigner(employerAddress)
 *   .addSigner(freelancerAddress)
 *   .complete();
 * ```
 */
export const redeemerRelease = Data.to(
  { ReleasePayment: [] } as JobAction,
  JobAction
);

/**
 * Cancel Job Redeemer
 *
 * Redeemer for cancelling a job and returning funds to employer.
 * Use this when the job needs to be cancelled for any reason.
 *
 * Smart Contract Validation:
 * - Both employer and freelancer must sign
 * - Payment amount must match locked amount
 * - Funds must go back to employer's address
 *
 * @constant
 * @type {string} Serialized CBOR redeemer
 *
 * @example
 * ```typescript
 * const tx = await lucid
 *   .newTx()
 *   .collectFrom([utxo], redeemerCancel)
 *   .attach.SpendingValidator(validator)
 *   .pay.ToAddress(employerAddress, assets)
 *   .addSigner(employerAddress)
 *   .addSigner(freelancerAddress)
 *   .complete();
 * ```
 */
export const redeemerCancel = Data.to(
  { CancelJob: [] } as JobAction,
  JobAction
);

// ===================================================================
// HELPER FUNCTIONS
// ===================================================================

/**
 * Parse Job Datum
 *
 * Deserializes a CBOR datum back into a JobDatum object.
 * Useful for reading and displaying locked escrow information.
 *
 * @param datumCbor - Serialized CBOR datum (hex string)
 * @returns Parsed JobDatum object
 *
 * @example
 * ```typescript
 * const utxo = await lucid.utxosAt(scriptAddress);
 * if (utxo[0].datum) {
 *   const datum = Data.from(utxo[0].datum, JobDatum);
 *   console.log("Employer:", datum.employer);
 *   console.log("Freelancer:", datum.freelancer);
 *   console.log("Job ID:", Buffer.from(datum.job_id, 'hex').toString('utf8'));
 * }
 * ```
 */
export function parseJobDatum(datumCbor: string): JobDatum {
  return Data.from(datumCbor, JobDatum);
}

/**
 * Decode Job ID
 *
 * Converts a hex-encoded job ID back to UTF-8 string.
 *
 * @param jobIdHex - Job ID as hex string (from datum)
 * @returns Decoded job ID as UTF-8 string
 *
 * @example
 * ```typescript
 * const datum = parseJobDatum(utxo.datum);
 * const jobId = decodeJobId(datum.job_id);
 * console.log("Job ID:", jobId); // "project_abc_001"
 * ```
 */
export function decodeJobId(jobIdHex: string): string {
  try {
    return Buffer.from(jobIdHex, 'hex').toString('utf8');
  } catch {
    return jobIdHex; // Return as-is if decoding fails
  }
}

// ===================================================================
// EXPORTS
// ===================================================================

export default {
  readValidator,
  createJobDatum,
  parseJobDatum,
  decodeJobId,
  redeemerRelease,
  redeemerCancel,
  JobDatum,
  JobAction,
};